import { parseCSV } from "./lib/stats.js";
import { indexOutcomes, indexPredictions, runBacktest, trainWeights, computeDAE, predictionToOutcome, normalizeOutcome } from "./lib/backtest.js";

const $ = (id) => document.getElementById(id);

let chart;

async function loadJson(url) {
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error(`${res.status} ${res.statusText} (${url})`);
  return await res.json();
}

async function loadText(url) {
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error(`${res.status} ${res.statusText} (${url})`);
  return await res.text();
}

function fmtPct(x) {
  if (!Number.isFinite(x)) return "â€“";
  return `${(100 * x).toFixed(1)}%`;
}

function outcomeEmoji(out) {
  if (out === "EARLY_SPRING") return "ðŸŒ±";
  if (out === "LONG_WINTER") return "â„ï¸";
  return "â€¦";
}

function outcomeEmoji3(out) {
  if (out === "EARLY_SPRING") return "ðŸŒ±";
  if (out === "EARLY_WINTER") return "ðŸ¥¶";
  if (out === "NORMAL_WINTER") return "â„ï¸";
  return "â€¦";
}

function setStatus(msg, kind="") {
  const el = $("status");
  el.textContent = msg;
  el.style.color = kind === "warn" ? "var(--warn)" : (kind === "bad" ? "var(--bad)" : "var(--muted)");
}

function getCfg() {
  const method = $("weightMethod").value;

  const beta = $("betaPrior").value.split(",").map(s => +s.trim()).filter(Number.isFinite);
  const betaPrior = beta.length === 2 ? beta : [2,2];

  const halfLifeYears = +$("halfLife").value || 10;

  return {
    method,
    target: $("target").value,
    opts: {
      minObs: +$("minObs").value || 0,
      betaPrior,
      halfLifeYears,
      alpha: 2.0,
      gamma: 0.5
    },
    dae: {
      minBacktestYears: +$("minBacktestYears").value || 10,
      maxCIHalfWidth: +$("maxCI").value || 0.10,
      minGroundhogs: +$("minGroundhogs").value || 8,
      minObsPerGroundhog: +$("minObs").value || 0
    }
  };
}

function summarizeTopWeights(weights, groundhogDir, n=12) {
  const nameBySlug = new Map((groundhogDir?.groundhogs ?? []).map(g => [g.slug, g.name || g.slug]));
  const arr = Array.from(weights.entries())
    .sort((a,b)=>b[1]-a[1])
    .slice(0,n)
    .map(([slug, w], i) => {
      const nm = nameBySlug.get(slug) ?? slug;
      return `${String(i+1).padStart(2," ")}  ${nm}  (${slug})  w=${w.toFixed(4)}`;
    });
  return arr.join("\n");
}

function renderChart(rows) {
  const pts = rows.filter(r => Number.isFinite(r.cumAcc)).map(r => ({ x: r.year, y: r.cumAcc }));
  const lo = rows.filter(r => r.ci && Number.isFinite(r.ci.lo)).map(r => ({ x: r.year, y: r.ci.lo }));
  const hi = rows.filter(r => r.ci && Number.isFinite(r.ci.hi)).map(r => ({ x: r.year, y: r.ci.hi }));

  const ctx = $("chartAccuracy").getContext("2d");
  if (chart) chart.destroy();

  chart = new Chart(ctx, {
    type: "line",
    data: {
      datasets: [
        { label: "Cumulative accuracy", data: pts, parsing: false, tension: 0.2, pointRadius: 0 },
        { label: "Wilson 95% CI (low)", data: lo, parsing: false, tension: 0.2, pointRadius: 0 },
        { label: "Wilson 95% CI (high)", data: hi, parsing: false, tension: 0.2, pointRadius: 0 },
      ]
    },
    options: {
      responsive: true,
      scales: {
        x: { type: "linear", ticks: { precision: 0 } },
        y: { min: 0, max: 1 }
      },
      plugins: {
        legend: { labels: { color: "#e6eaf0" } }
      }
    }
  });
}

function computeSinceDAE(rows, daeYear) {
  if (!daeYear) return null;
  const subset = rows.filter(r => r.year >= daeYear && r.correct !== null);
  if (!subset.length) return null;
  const k = subset.filter(r => r.correct).length;
  const n = subset.length;
  return { k, n, acc: k/n };
}

async function run() {
  setStatus("Loading dataâ€¦");
  $("nowcast").textContent = "";
  $("sinceDae").textContent = "";
  $("severity").textContent = "";

  // Load cached data (generated by scripts or seeded samples)
  const [predObj, ghObj, outcomesText] = await Promise.all([
    loadJson("./data/predictions.json"),
    loadJson("./data/groundhogs.json"),
    loadText("./data/outcomes.csv")
  ]);

  const outcomesRows = parseCSV(outcomesText);
  const outcomes = indexOutcomes(outcomesRows);
  const predByYear = indexPredictions(predObj);

  // If outcomes.csv includes the winter_bucket rule comment, extract the threshold for display.
  const thrMatch = outcomesText.match(/mean_anom\s*<=\s*-([0-9.]+)F/i);
  const winterThr = thrMatch ? Number.parseFloat(thrMatch[1]) : null;

  $("dataDump").textContent = JSON.stringify({
    predictionsUpdatedAt: predObj.updatedAt,
    groundhogsUpdatedAt: ghObj.updatedAt,
    outcomesRows: outcomesRows.length,
    outcomesHasWinterBucket: outcomesRows.some(r => (r.winter_bucket ?? "").trim().length)
  }, null, 2);

  const cfg = getCfg();

  // Backtest
  setStatus("Running backtestâ€¦");
  const rows = runBacktest(predByYear, outcomes, cfg.target, cfg.method, cfg.opts);

  if (!rows.length) {
    setStatus("No backtest rows. You probably need outcomes for the selected target.", "warn");
    $("notes").textContent = "Tip: run `npm run update:predictions` and fill `docs/data/outcomes.csv` (or run the NOAA helper).";
    return;
  }

  // DAE
  const daeYear = computeDAE(rows, cfg.dae);

  // â€œNowcastâ€ = latest year that has predictions (may not have outcome yet)
  const latestYear = Math.max(...Array.from(predByYear.keys()));
  const { weights } = trainWeights(predByYear, outcomes, cfg.target, latestYear, cfg.method, cfg.opts);

  const latestPreds = predByYear.get(latestYear) ?? [];
  // Use ensemble only if some weighted groundhogs are present that year
  let nowcast = "";
  let used = 0;
  let score = 0;
  for (const p of latestPreds) {
    const w = weights.get(p.groundhogSlug);
    if (!w) continue;
    used++;
    const out = predictionToOutcome(!!p.shadow);
    score += w * (out === "EARLY_SPRING" ? 1 : -1);
  }
  if (used) nowcast = score >= 0 ? "EARLY_SPRING" : "LONG_WINTER";

  const lastRow = rows.findLast(r => r.cumAcc !== undefined) ?? rows[rows.length - 1];

  // Render
  renderChart(rows);

  const since = computeSinceDAE(rows, daeYear);
  const daeText = daeYear ? `DAE = ${daeYear}` : "DAE not reached yet (tighten/loosen thresholds?)";

  $("nowcast").innerHTML = `
    <div>Latest prediction year in dataset: <b>${latestYear}</b></div>
    <div>Ensemble vote: <b>${outcomeEmoji(nowcast)} ${nowcast || "N/A"}</b> (weighted voters: ${used})</div>
    <div>Backtest cumulative accuracy (through ${lastRow.year}): <b>${fmtPct(lastRow.cumAcc)}</b> (n=${lastRow.cumN})</div>
    <div>${daeText}</div>
  `;

  // Winter intensity breakdown (still ONLY 2 outcomes for scoring)
  const relevant = outcomesRows.filter(r => String(r.target).trim() === cfg.target);
  const longWinterRows = relevant.filter(r => normalizeOutcome(r.outcome) === "LONG_WINTER");
  const earlyWinter = longWinterRows.filter(r => String(r.winter_bucket ?? "").trim().toUpperCase() === "EARLY_WINTER").length;
  const normalWinter = longWinterRows.filter(r => {
    const wb = String(r.winter_bucket ?? "").trim().toUpperCase();
    return wb === "NORMAL_WINTER" || wb === "";
  }).length;
  const thrText = (winterThr !== null && Number.isFinite(winterThr)) ? ` (EARLY_WINTER if mean_anom <= -${winterThr}Â°F)` : "";
  if (longWinterRows.length) {
    $("severity").textContent = `Winter intensity${thrText}: EARLY_WINTER=${earlyWinter}, NORMAL_WINTER=${normalWinter}. (Scoring outcomes remain binary: EARLY_SPRING vs LONG_WINTER.)`;
  } else {
    $("severity").textContent = `Winter intensity${thrText}: no LONG_WINTER rows found for this target.`;
  }

  if (since) {
    $("sinceDae").textContent = `Since ${daeYear}, ensemble accuracy: ${fmtPct(since.acc)} (n=${since.n}).`;
  } else if (daeYear) {
    $("sinceDae").textContent = `Since ${daeYear}, there are no scored years yet (outcomes missing).`;
  } else {
    $("sinceDae").textContent = "Once DAE is reached, you can truthfully claim â€œSince YEAR, weâ€™ve been X% accurate.â€";
  }



  $("topGroundhogs").textContent = summarizeTopWeights(weights, ghObj, 15);

  // Notes
  const isSample = String(predObj.updatedAt || "").includes("SAMPLE");
  $("notes").textContent = isSample
    ? "You are viewing sample data. Run `npm run update:predictions` (and optionally outcomes) to get real history."
    : "Tip: the outcome rule is a modeling choice. Be explicit about it on your site.";
  setStatus("Done.");
}

function wire() {
  $("runBtn").addEventListener("click", () => run().catch(e => {
    console.error(e);
    setStatus(String(e), "bad");
  }));

  for (const id of ["weightMethod","betaPrior","halfLife","minObs","minBacktestYears","maxCI","minGroundhogs","target"]) {
    $(id).addEventListener("change", () => run().catch(()=>{}));
  }

  run().catch(e => {
    console.error(e);
    setStatus(String(e), "bad");
  });
}

wire();
